# Teoria de Listas

Baseado no trabalho de Richard S. Bird.

## Nota√ß√£o

Uma lista √© uma *cole√ß√£o linearmente ordenada* de valores de **mesma natureza**; podemos falar sobre o primeiro elemento da lista, o segundo elemento e assim por diante. Listas tamb√©m s√£o chamadas de *sequ√™ncias*. Uma lista finita √© descrita atrav√©s de colchetes e os elementos s√£o separados por v√≠rgulas. Por exemplo, `[1,2,3]` √© uma lista de tr√™s inteiros e `[['a','l','√¥'],['a','l','√¥']]` √© uma lista com dois elementos e cada elemento √© uma lista de tr√™s caracteres. A lista vazia √© escrita como `[]`, e, uma lista unit√°ria (singleton) contendo um √∫nico elemento `a` √© escrita como `[a]`. Em particular, a lista `[[]]` √© um **singleton** contendo a lista vazia como seu √∫nico elemento. Listas podem ser infinitas tamb√©m, por√©m no nosso contexto s√≥ faz sentido falarmos de listas finitas.

Diferente dos conjuntos, as listas podem abrigar elementos repetidos. Por exemplo, `[1,1]` √© uma lista com dois elementos. A forma especial `[m..n]` √© usada pra denotar a lista de inteiros **em ordem crescente** de `m` at√© `n` (inclusivo). Se `m > n`, ent√£o `[m..n] = []`.

Em Python, linguagem escolhida para esse post, as listas possuem a mesma nota√ß√£o descrita acima. Apesar de n√£o ser recomendado, as listas em Python podem possuir elementos de tipos diferentes. Por exemplo, em Python a lista `[1, 'a']` √© uma lista com dois elementos de tipos distintos.

## Opera√ß√µes Elementares

### Length

O tamanho (**length**) de uma lista finita √© o n√∫mero de elementos contidos na lista. N√≥s denotamos essa opera√ß√£o pelo operador `#`. Logo:

```
#[a‚ÇÅ, a‚ÇÇ, a‚ÇÉ, ..., a‚Çô] = n
```

Python fornece uma fun√ß√£o na biblioteca padr√£o chamada `len` que retorna o tamanho de uma determinada lista:

```python
> len([1,2,3])
3
> len([])
0
```

### Concatena√ß√£o 

Duas listas podem ser concatenadas para formar uma outra lista. Essa fun√ß√£o √© denotada pelo operador `‚ß∫`. Logo:

```
    [a‚ÇÅ, a‚ÇÇ, ..., a‚Çô] ‚ß∫ [b‚ÇÅ, b‚ÇÇ, ..., b‚Çô] = [a‚ÇÅ, a‚ÇÇ, ..., a‚Çô, b‚ÇÅ, b‚ÇÇ, ..., b‚Çô] 
```

Em particular, n√≥s temos que (considere `x` como uma lista qualquer):

```
    [] ‚ß∫ x = x ‚ß∫ [] = x
```

De forma que a lista vazia `[]` √© o elemento identidade do operador concatena√ß√£o `‚ß∫`.

A concatena√ß√£o tamb√©m √© associativa, ou seja:

```
    x ‚ß∫ (y ‚ß∫ z) = (x ‚ß∫ y) ‚ß∫ z
```
Para toda lista `x, y e z`.

Um relacionamento simples entre `# (length)` e `‚ß∫ (concat)` √© dado pela equa√ß√£o abaixo:

```
    #(x ‚ß∫ y) = #x + #y
```

Para toda lista finita `x` e `y`. Ou seja, o tamanho da concatena√ß√£o de duas listas √© a soma dos tamanhos das listas individuais.

Em Python o operador `+` √© sobrecarregado e serve como operador de concatena√ß√£o de listas.

```python
>>> x = [1]
>>> y = [2,3]
>>> z = [4,5,6]
>>> x + []                        # Identidade 
[1]
>>> [] + x
[1]
>>> x + y                         # Concatena√ß√£o
[1,2,3]
>>> x + (y + z) == (x + y) + z    # Associatividade
True
>>> len(x+y) == len(x) + len(y)
True
>>> 
```
 No exemplo acima, do lado esquerdo, o operador `+` tem a fun√ß√£o de concatenar as duas listas. No lado direito ele soma os tamanhos das listas. Vejamos:
 
 ```
 Lado esquerdo da express√£o (tamanho de concat):
    len([1] + [2, 3])
    len([1,2,3])
    3
Lado direito da express√£o (soma de tamanhos):
    len([1]) + len([2,3])
    1 + len([2,3])
    1 + 2
    3
 ```
 
 Por isso a express√£o retornou `True`.

As listas com a opera√ß√£o de concatena√ß√£o formam um `Monoid`, vejamos as regras:

```
- ‚ß∫ √© uma opera√ß√£o bin√°ria fechada (recebe listas e retorna listas) e associativa (check)
- [] √© o elemento identidade da concatena√ß√£o (check)
```

## Map

O operador `*`, conhecido como `map` aplica uma fun√ß√£o para cada elemento da lista, retornando uma nova lista. Temos que:

```
    ùëì * [a‚ÇÅ,a‚ÇÇ,..., a‚Çô] = [ùëì a‚ÇÅ, ùëì a‚ÇÇ,..., ùëì a‚Çô] 
```

A lista resultante dessa opera√ß√£o tem o mesmo tamanho da lista original e os elementos est√£o dispostos na mesma ordem com ùëì aplicado a cada um deles.

Exemplo, seja a fun√ß√£o **even** um predicado que retorna `True` quando um n√∫mero √© par e `False` quando um n√∫mero √© √≠mpar:

```
    even * [1..4] = [False, True, False, True]
    [even 1, even 2, even 3, even 4]
    [False, even 2, even 3, even 4]
    [False, True, even 3, even 4]
    [False, True, False, even 4]
    [False, True, False, True]
```

Em Python vamos implementar nossa pr√≥pria vers√£o da fun√ß√£o `map`. Ela pode ser escrita de forma iterativa ou recursiva. Vejamos:

```python
    # Vers√£o iterativa
    def my_map(funcao, lista):
        resultado = []
        for item in lista:
            resultado.append(funcao(item))
        return resultado
```

Vejamos o exemplo em Python:

```python
>>> even = (lambda x: x%2 == 0)
>>> my_map(even, [1,2,3,4])
[False, True, False, True]
>>> inc = (lambda x: x+1)
>>> my_map(inc, [1,2,3,4])
[2,3,4,5]
>>>
```

Python tem s√©rias limita√ß√µes quando o assunto √© recurs√£o (sem tail call optimization), por isso essa vers√£o recursiva:

```python
    # Vers√£o recursiva
    # para remover esse 'i' da lista de parametros vc pode criar uma fun√ß√£o interna
    def my_map(funcao, lista, i):
        if i==len(lista):
            return []
        return [funcao(lista[i])] + my_map(funcao, lista, i+1)
```

No exemplo acima, no return, estou criando uma lista singleton e concatenando com a chamada recursiva com o restante da lista. Os resultados v√£o ser igual ao do exemplo anterior.

```python
    # Vers√£o recursiva com fun√ß√£o aninhada
    def my_map(funcao, lista):
        def aux(funcao, lista, i):
            if i==len(lista):
                return []
            return [funcao(lista[i])] + my_map(funcao, lista, i+1)
        return aux(funcao, lista, 0)
    
```

Uma propriedade interessante do `map` √© que ela distribui sobre `‚ß∫`. Veja que:

```
   ùëì * (x ‚ß∫ y) = (ùëì * x) ‚ß∫ (ùëì * y) 
```

Isso quer dizer que, sejam x e y listas:

```
    map(ùëì, x ‚ß∫ y) = map(ùëì, x) ‚ß∫ map(ùëì, y) 
```

Em python podemos ver que:

```python
    my_map(inc, [1,2,3] + [4,5,6]) == my_map(inc, [1,2,3]) + my_map(inc, [4,5,6])
```

Vamos resolver a express√£o √† esquerda da compara√ß√£o:

```python
    my_map(inc, [1,2,3] + [4,5,6])
    my_map(inc, [1,2,3,4,5,6])
    [2,3,4,5,6,7]
```

Vamos agora resolver a express√£o do lado direito da compara√ß√£o:

```python
    my_map(inc, [1,2,3]) + my_map(inc, [4,5,6])
    [2,3,4] + my_map(inc, [4,5,6])
    [2,3,4] + [5,6,7]
    [2,3,4,5,6,7]
```

## Filter ‚óÉ

O operador `‚óÉ`, conhecido como filter, recebe um predicado(fun√ß√£o booleana) `p` e uma lista `x` e retorna a lista de elementos de `x` que satisfazem `p`. Por exemplo:

```
    even ‚óÉ [1..10] = [2,4,6,8,10]
```

Assim como map `*`, filter tamb√©m distribui sobre a concatena√ß√£o `‚ß∫`. Para toda lista x e y:

```
    p ‚óÉ (x ‚ß∫ y) = (p ‚óÉ x) ‚ß∫ (p ‚óÉ y)
```

Algumas identidades, seja `x` uma lista qualquer e `p e q` predicados:

```
    p ‚óÉ q ‚óÉ x = q ‚óÉ p ‚óÉ x
    p ‚óÉ p ‚óÉ x = p ‚óÉ x
    p ‚óÉ ùëì * x = ùëì * (p . ùëì) ‚óÉ x   (p . ùëì) √© a composi√ß√£o de p com ùëì
```
A primeira lei (comutatividade de filtros) diz que filtrar uma lista com um predicado `q` e depois filtrar o resultado com o predicado `p` vai dar o mesmo resultado que filtrar a lista com o predicado `p` e depois filtrar o resultado com o predicaado `q`.
A segunda lei (idempot√™ncia) diz que n√£o importa quantas vezes eu filtre a lista com *o mesmo predicado* o resultado sempre ser√° o mesmo. 

Vamos ver agora em Python. Primeiramente vamos mostrar uma implementa√ß√£o iterativa de filter. Depois mostraremos as leis e propriedades estabelecidas.

```python
    # Implementa√ß√£o iterativa
    def my_filter(predicado, lista):
        resultado = []
        for item in lista:
            if predicado(item):
                resultado.append(item)
        return resultado
    
    # Implementa√ß√£o recursiva
    def my_filter(pred, lista):
        pass
```

A implementa√ß√£o de filter recursivo fica como exerc√≠cio para o leitor.

```python
    >>> even = lambda x: x%2==0
    >>> gt_ten = lambda x: x>10
    >>> inc = lambda x: x+1
    >>> comp = lambda x,y: lambda z: x(y(z))
    >>> my_filter(even, [1,2,3,4,5,6,7,8,9,10])
    [2,4,6,8,10]
    
    # Distributiva sobre a concatena√ß√£o diz que:
    >>> my_filter(even, [1,2,3] + [4,5,6]) == my_filter(even, [1,2,3]) + my_filter(even, [4,5,6])
    True
    
    # Em ambos os casos o resultado √© o mesmo: [2,4,6]

    # Vamos para a primeira lei que fala sobre a comutatividade dos filtros:
    >>> my_filter(even, my_filter(gt_ten, [4,5,6,7,8,9,10,11,12]))
    [12]
    >>> my_filter(gt_ten, my_filter(even, [4,5,6,7,8,9,10,11,12]))
    [12]
    
    # A comutatividade √© verdadeira. No 1o caso eu primeiro filtro os maiores de 10 e depois eu filtro os pares. No segundo caso primeiro eu filtro os pares e depois eu filtro os maiores de 10. O resultado √© o mesmo.
    
    # Vamos verificar a idempot√™ncia:
    >>> my_filter(even, [4,5,6,7,8,9,10,11,12])
    [4, 6, 8, 10, 12]
    >>> my_filter(even, my_filter(even, [4,5,6,7,8,9,10,11,12]))
    [4, 6, 8, 10, 12]
    
    Idempot√™ncia, checked.
    
    # Vamos verificar a √∫ltima lei, comutatividade do filter e map.
    >>> my_filter(even, my_map(inc, [1,2,3,4,5]))
    [2, 4, 6]
    >>> my_map(inc, my_filter(comp(even,inc),[1,2,3,4,5]))
    [2, 4, 6]
```

Aparentemente as leis est√£o sendo garantidas pela nossa implementa√ß√£o. 

## Finalmentes

Esse artigo √© baseado nas notas de aula do professor Richard S. Bird da Universidade de Oxford e, apesar do foco ser na matem√°tica, n√≥s vimos que podemos traduzir os conceitos de forma bastante direta para uma linguagem de programa√ß√£o que possui fun√ß√µes como objetos de primeira classe. A ideia do trabalho √© especificar e manipular fun√ß√µes comput√°veis sobre listas. Na pr√≥xima ocasi√£o eu vou abordar a fun√ß√£o `reduce` e vou mostrar (espero) como map e filter s√£o apenas casos especiais de reduce.
